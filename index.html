<!DOCTYPE html>
<html>

<head>
	<title>Frag Shader</title>
	<style>
		body,
		html {
			margin: 0;
			padding: 0;
			overflow: hidden;
		}

		canvas {
			display: block;
		}
	</style>
</head>

<body>
	<canvas id="canvas"></canvas>
	<script type="x-shader/x-fragment" id="fragmentShader"></script>

	<script>
		window.onload = function () {
			var canvas = document.getElementById('canvas');
			var gl = canvas.getContext('webgl');

			var idx = 1;

			function resizeCanvas() {
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;

				gl.viewport(0, 0, canvas.width, canvas.height);

				draw(`frag-${idx}.glsl`);
			}
			resizeCanvas();

			window.addEventListener('resize', resizeCanvas);
			window.addEventListener('keydown', function (event) {
				switch (event.key) {
					case "ArrowLeft":
						idx -= 1;
						break;
					case "ArrowRight":
						idx += 1;
						break;
				}
				resizeCanvas();
			});

			var vertexShaderSource = `
attribute vec2 a_position;

void main()
{
   gl_Position = vec4(a_position, 0.0, 1.0);
}
            `;

			function draw(source) {
				fetch(source).then(r => r.text()).then(text => {
					var fragmentShaderSource = text;

					// Compile and link shaders
					var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
					var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
					var program = createProgram(gl, vertexShader, fragmentShader);
					gl.useProgram(program);

					var vertices = [
						-1, -1, // Bottom-left
						1, -1, // Bottom-right
						1, 1,  // Top-right
						-1, 1  // Top-left
					];
					var vertexBuffer = gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

					// Configure attributes and uniforms
					var positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
					gl.enableVertexAttribArray(positionAttributeLocation);
					gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

					var resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
					gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);

					gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
				})
			}

			// Helper functions for shader creation
			function createShader(gl, type, source) {
				var shader = gl.createShader(type);
				gl.shaderSource(shader, source);
				gl.compileShader(shader);

				var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
				if (!success) {
					console.log(gl.getShaderInfoLog(shader));
					gl.deleteShader(shader);
					return null;
				}

				return shader;
			}

			function createProgram(gl, vertexShader, fragmentShader) {
				var program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				gl.linkProgram(program);

				var success = gl.getProgramParameter(program, gl.LINK_STATUS);
				if (!success) {
					console.log(gl.getProgramInfoLog(program));
					gl.deleteProgram(program);
					return null;
				}

				return program;
			}
		};
	</script>
</body>

</html>